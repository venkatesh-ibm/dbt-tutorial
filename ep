import boto3
import datetime

def lambda_handler(event=None, context=None):
    days_to_check = 3
    end_time = datetime.datetime.utcnow()
    start_time = end_time - datetime.timedelta(days=days_to_check)
    period = 86400  # daily

    region = "eu-west-1"
    print(f"=== Processing region: {region} ===")
    ec2 = boto3.client('ec2', region_name=region)
    cloudwatch = boto3.client('cloudwatch', region_name=region)

    endpoints_resp = ec2.describe_vpc_endpoints()
    endpoints = endpoints_resp.get('VpcEndpoints', [])[:3]
    print(f"Found {len(endpoints)} endpoints in {region} (limited to 3 for test)")

    vpcs = ec2.describe_vpcs()['Vpcs']
    vpc_name_map = {
        vpc['VpcId']: next((tag['Value'] for tag in vpc.get('Tags', []) if tag['Key'] == 'Name'), '')
        for vpc in vpcs
    }

    unused_endpoints = []

    for idx, ep in enumerate(endpoints, start=1):
        ep_id = ep['VpcEndpointId']
        vpc_id = ep['VpcId']
        vpc_name = vpc_name_map.get(vpc_id, '')
        ep_type = ep['VpcEndpointType']
        ep_service = ep['ServiceName']

        print(f"[{region}] Endpoint {idx}/{len(endpoints)}: {ep_id} ({ep_type} - {ep_service}) in VPC {vpc_name}")

        traffic_bytes = 0
        is_referenced = False

        # First check if metrics exist for this endpoint
        try:
            metrics_list = cloudwatch.list_metrics(
                Namespace='AWS/PrivateLink',
                Dimensions=[{'Name': 'VpcEndpointId', 'Value': ep_id}]
            )
        except Exception as e:
            print(f"  Error listing metrics for {ep_id}: {e}")
            metrics_list = {'Metrics': []}

        if not metrics_list['Metrics']:
            print(f"  No CloudWatch metrics found for {ep_id} â€” skipping metrics fetch")
        else:
            try:
                metrics = cloudwatch.get_metric_statistics(
                    Namespace='AWS/PrivateLink',
                    MetricName='BytesProcessed',
                    Dimensions=[{'Name': 'VpcEndpointId', 'Value': ep_id}],
                    StartTime=start_time,
                    EndTime=end_time,
                    Period=period,
                    Statistics=['Sum']
                )
                for dp in metrics['Datapoints']:
                    traffic_bytes += dp['Sum']
                print(f"  Metrics total: {traffic_bytes} bytes in last {days_to_check} days")
            except Exception as e:
                print(f"  Error fetching metrics for {ep_id}: {e}")

        if ep_type == 'Gateway':
            print(f"  Checking route table references for Gateway endpoint {ep_id}...")
            try:
                for rt in ec2.describe_route_tables()['RouteTables']:
                    for route in rt.get('Routes', []):
                        if route.get('GatewayId') == ep_id:
                            is_referenced = True
                            print(f"    Found reference in route table {rt['RouteTableId']}")
                            break
            except Exception as e:
                print(f"  Error checking route tables: {e}")

        elif ep_type == 'Interface':
            print(f"  Checking ENI attachments for Interface endpoint {ep_id}...")
            try:
                for eni in ep.get('NetworkInterfaceIds', []):
                    eni_data = ec2.describe_network_interfaces(NetworkInterfaceIds=[eni])['NetworkInterfaces'][0]
                    if eni_data.get('Attachment'):
                        is_referenced = True
                        print(f"    ENI {eni} is attached to a resource")
            except Exception as e:
                print(f"  Error checking ENIs: {e}")

        if traffic_bytes == 0 and not is_referenced:
            print(f"  => Marking {ep_id} as UNUSED")
            unused_endpoints.append({
                'Region': region,
                'VpcEndpointId': ep_id,
                'VpcId': vpc_id,
                'VpcName': vpc_name,
                'Type': ep_type,
                'Service': ep_service
            })
        else:
            print(f"  => {ep_id} still in use (traffic or reference found)")

    print("\n===== Scan complete =====")
    print(f"Total unused endpoints: {len(unused_endpoints)}")
    for ep in unused_endpoints:
        print(ep)

    return unused_endpoints

if __name__ == "__main__":
    lambda_handler()
